MVP = MVC logic (what MVC really should be) comes true in this architecture pattern

Passive controller here, presenter does all the logics and getting all the info to the controller, V - View, and M - Model. 

Higher maintenance	, can also test most of the business logic due to the passive view/controller 

MVVM - 

M - Model, this is the plain data
V - View/Controller 
VM - ViewModel 

ViewModel does all the logic that has to do with data, including talking to different entity to get data 
View/Controller - is passive but not as passive as the View/controller in MVP 
Model has plain data 

Testability — can test ViewModel since it doesn’t know the existence of View 
Higher maintenance	, better distribution 

Viper — View Presenter, Interactor, Router, Entity 
                         View/Controller - passive
		    Presenter, gets everything for View/Controller plus some logics
		   Interactor — all the data related logics plus get the data related things for presenter
                         Entity - plain model
                         Router - communications btwn modules 
High maintenance, high testability, balance distributions 

Flux —  architecture pattern based on UI state changes 
              View, Action, Store, Dispatcher
View notifies Action, Action gets the right dispatcher, dispatcher gives the right state to store, and store change the right state to View 


Singleton 
Strategy — encapsulates algorithms in classes, making them reusable and interchangeable at runtime, it’s behavioral pattern. 
When to use: 
 Different ways to do the same, instead of inheritance, alternatives to if/else blocks

Singleton 
 — only one instance of class is instantiated, global access 
 — dependency injection 

Observer — emphasized on object reaction when there’s a change or another events from Observable. 
           Observer has characteristics to fulfill the patttern as follows:
               — has a observables
               — attaching and removing observables
              —notify the observables about the changes 
Facade — allows us to simplify the way we interact with complicated APIs by hiding the internal implementation details under the hood and exposing simple methods for the clients

Factory — is a way to encapsulate the implementation details of creating objects which adheres to a common base class or interface 

Decorator — dynamically modifies the behavior of a core object without changing its existing class definition 

Adapter -a structural design pattern that allows objects with incompatible interfaces to work together
