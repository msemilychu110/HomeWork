{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww25400\viewh13620\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 MVC \'97 Model View Controller, Controller can get too massive since view and controller are tightly coupled \
But its low maintenance, easy to use, testability for model \
\
MVP = MVC logic (what MVC really should be) comes true in this architecture pattern\
\
Passive controller here, presenter does all the logics and getting all the info to the controller, V - View, and M - Model. \
\
Higher maintenance	, can also test most of the business logic due to the passive view/controller \
\
MVVM - \
\
M - Model, this is the plain data\
V - View/Controller \
VM - ViewModel \
\
ViewModel does all the logic that has to do with data, including talking to different entity to get data \
View/Controller - is passive but not as passive as the View/controller in MVP \
Model has plain data \
\
Testability \'97 can test ViewModel since it doesn\'92t know the existence of View \
Higher maintenance	, better distribution \
\
Viper \'97 View Presenter, Interactor, Router, Entity \
                         View/Controller - passive\
		    Presenter, gets everything for View/Controller plus some logics\
		   Interactor \'97 all the data related logics plus get the data related things for presenter\
                         Entity - plain model\
                         Router - communications btwn modules \
High maintenance, high testability, balance distributions \
\
Flux \'97  architecture pattern based on UI state changes \
              View, Action, Store, Dispatcher\
View notifies Action, Action gets the right dispatcher, dispatcher gives the right state to store, and store change the right state to View \
\
\
Singleton \
Strategy \'97 encapsulates algorithms in classes, making them reusable and interchangeable at runtime, it\'92s behavioral pattern. \
When to use: \
 Different ways to do the same, instead of inheritance, alternatives to if/else blocks\
\
Singleton \
 \'97 only one instance of class is instantiated, global access \
 \'97 dependency injection \
\
Observer \'97 emphasized on object reaction when there\'92s a change or another events from Observable. \
           Observer has characteristics to fulfill the patttern as follows:\
               \'97 has a observables\
               \'97 attaching and removing observables\
              \'97notify the observables about the changes \
Facade \'97 allows us to simplify the way we interact with complicated APIs by hiding the internal implementation details under the hood and exposing simple methods for the clients\
\
Factory \'97 is a way to encapsulate the implementation details of creating objects which adheres to a common base class or interface \
\
Decorator \'97 dynamically modifies the behavior of a core object without changing its existing class definition \
\
Adapter -a structural design pattern that allows objects with incompatible interfaces to work together}